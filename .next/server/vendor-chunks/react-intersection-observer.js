"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-intersection-observer";
exports.ids = ["vendor-chunks/react-intersection-observer"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-intersection-observer/react-intersection-observer.m.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/react-intersection-observer/react-intersection-observer.m.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InView: () => (/* binding */ InView),\n/* harmony export */   \"default\": () => (/* binding */ InView),\n/* harmony export */   defaultFallbackInView: () => (/* binding */ defaultFallbackInView),\n/* harmony export */   observe: () => (/* binding */ observe),\n/* harmony export */   useInView: () => (/* binding */ useInView)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nvar observerMap = new Map();\nvar RootIds = new WeakMap();\nvar rootId = 0;\nvar unsupportedValue = undefined;\n/**\r\n * What should be the default behavior if the IntersectionObserver is unsupported?\r\n * Ideally the polyfill has been loaded, you can have the following happen:\r\n * - `undefined`: Throw an error\r\n * - `true` or `false`: Set the `inView` value to this regardless of intersection state\r\n * **/ function defaultFallbackInView(inView) {\n    unsupportedValue = inView;\n}\n/**\r\n * Generate a unique ID for the root element\r\n * @param root\r\n */ function getRootId(root) {\n    if (!root) return \"0\";\n    if (RootIds.has(root)) return RootIds.get(root);\n    rootId += 1;\n    RootIds.set(root, rootId.toString());\n    return RootIds.get(root);\n}\n/**\r\n * Convert the options to a string Id, based on the values.\r\n * Ensures we can reuse the same observer when observing elements with the same options.\r\n * @param options\r\n */ function optionsToId(options) {\n    return Object.keys(options).sort().filter(function(key) {\n        return options[key] !== undefined;\n    }).map(function(key) {\n        return key + \"_\" + (key === \"root\" ? getRootId(options.root) : options[key]);\n    }).toString();\n}\nfunction createObserver(options) {\n    // Create a unique ID for this observer instance, based on the root, root margin and threshold.\n    var id = optionsToId(options);\n    var instance = observerMap.get(id);\n    if (!instance) {\n        // Create a map of elements this observer is going to observe. Each element has a list of callbacks that should be triggered, once it comes into view.\n        var elements = new Map();\n        var thresholds;\n        var observer = new IntersectionObserver(function(entries) {\n            entries.forEach(function(entry) {\n                var _elements$get;\n                // While it would be nice if you could just look at isIntersecting to determine if the component is inside the viewport, browsers can't agree on how to use it.\n                // -Firefox ignores `threshold` when considering `isIntersecting`, so it will never be false again if `threshold` is > 0\n                var inView = entry.isIntersecting && thresholds.some(function(threshold) {\n                    return entry.intersectionRatio >= threshold;\n                }); // @ts-ignore support IntersectionObserver v2\n                if (options.trackVisibility && typeof entry.isVisible === \"undefined\") {\n                    // The browser doesn't support Intersection Observer v2, falling back to v1 behavior.\n                    // @ts-ignore\n                    entry.isVisible = inView;\n                }\n                (_elements$get = elements.get(entry.target)) == null ? void 0 : _elements$get.forEach(function(callback) {\n                    callback(inView, entry);\n                });\n            });\n        }, options); // Ensure we have a valid thresholds array. If not, use the threshold from the options\n        thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [\n            options.threshold || 0\n        ]);\n        instance = {\n            id: id,\n            observer: observer,\n            elements: elements\n        };\n        observerMap.set(id, instance);\n    }\n    return instance;\n}\n/**\r\n * @param element - DOM Element to observe\r\n * @param callback - Callback function to trigger when intersection status changes\r\n * @param options - Intersection Observer options\r\n * @param fallbackInView - Fallback inView value.\r\n * @return Function - Cleanup function that should be triggered to unregister the observer\r\n */ function observe(element, callback, options, fallbackInView) {\n    if (options === void 0) {\n        options = {};\n    }\n    if (fallbackInView === void 0) {\n        fallbackInView = unsupportedValue;\n    }\n    if (typeof window.IntersectionObserver === \"undefined\" && fallbackInView !== undefined) {\n        var bounds = element.getBoundingClientRect();\n        callback(fallbackInView, {\n            isIntersecting: fallbackInView,\n            target: element,\n            intersectionRatio: typeof options.threshold === \"number\" ? options.threshold : 0,\n            time: 0,\n            boundingClientRect: bounds,\n            intersectionRect: bounds,\n            rootBounds: bounds\n        });\n        return function() {};\n    } // An observer with the same options can be reused, so lets use this fact\n    var _createObserver = createObserver(options), id = _createObserver.id, observer = _createObserver.observer, elements = _createObserver.elements; // Register the callback listener for this element\n    var callbacks = elements.get(element) || [];\n    if (!elements.has(element)) {\n        elements.set(element, callbacks);\n    }\n    callbacks.push(callback);\n    observer.observe(element);\n    return function unobserve() {\n        // Remove the callback from the callback list\n        callbacks.splice(callbacks.indexOf(callback), 1);\n        if (callbacks.length === 0) {\n            // No more callback exists for element, so destroy it\n            elements[\"delete\"](element);\n            observer.unobserve(element);\n        }\n        if (elements.size === 0) {\n            // No more elements are being observer by this instance, so destroy it\n            observer.disconnect();\n            observerMap[\"delete\"](id);\n        }\n    };\n}\nvar _excluded = [\n    \"children\",\n    \"as\",\n    \"triggerOnce\",\n    \"threshold\",\n    \"root\",\n    \"rootMargin\",\n    \"onChange\",\n    \"skip\",\n    \"trackVisibility\",\n    \"delay\",\n    \"initialInView\",\n    \"fallbackInView\"\n];\nfunction isPlainChildren(props) {\n    return typeof props.children !== \"function\";\n}\n/**\r\n ## Render props\r\n\n To use the `<InView>` component, you pass it a function. It will be called\r\n whenever the state changes, with the new value of `inView`. In addition to the\r\n `inView` prop, children also receive a `ref` that should be set on the\r\n containing DOM element. This is the element that the IntersectionObserver will\r\n monitor.\r\n\n If you need it, you can also access the\r\n [`IntersectionObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry)\r\n on `entry`, giving you access to all the details about the current intersection\r\n state.\r\n\n ```jsx\r\n import { InView } from 'react-intersection-observer';\r\n\n const Component = () => (\r\n <InView>\r\n {({ inView, ref, entry }) => (\r\n      <div ref={ref}>\r\n        <h2>{`Header inside viewport ${inView}.`}</h2>\r\n      </div>\r\n    )}\r\n </InView>\r\n );\r\n\n export default Component;\r\n ```\r\n\n ## Plain children\r\n\n You can pass any element to the `<InView />`, and it will handle creating the\r\n wrapping DOM element. Add a handler to the `onChange` method, and control the\r\n state in your own component. Any extra props you add to `<InView>` will be\r\n passed to the HTML element, allowing you set the `className`, `style`, etc.\r\n\n ```jsx\r\n import { InView } from 'react-intersection-observer';\r\n\n const Component = () => (\r\n <InView as=\"div\" onChange={(inView, entry) => console.log('Inview:', inView)}>\r\n <h2>Plain children are always rendered. Use onChange to monitor state.</h2>\r\n </InView>\r\n );\r\n\n export default Component;\r\n ```\r\n */ var InView = /*#__PURE__*/ function(_React$Component) {\n    _inheritsLoose(InView, _React$Component);\n    function InView(props) {\n        var _this;\n        _this = _React$Component.call(this, props) || this;\n        _this.node = null;\n        _this._unobserveCb = null;\n        _this.handleNode = function(node) {\n            if (_this.node) {\n                // Clear the old observer, before we start observing a new element\n                _this.unobserve();\n                if (!node && !_this.props.triggerOnce && !_this.props.skip) {\n                    // Reset the state if we get a new node, and we aren't ignoring updates\n                    _this.setState({\n                        inView: !!_this.props.initialInView,\n                        entry: undefined\n                    });\n                }\n            }\n            _this.node = node ? node : null;\n            _this.observeNode();\n        };\n        _this.handleChange = function(inView, entry) {\n            if (inView && _this.props.triggerOnce) {\n                // If `triggerOnce` is true, we should stop observing the element.\n                _this.unobserve();\n            }\n            if (!isPlainChildren(_this.props)) {\n                // Store the current State, so we can pass it to the children in the next render update\n                // There's no reason to update the state for plain children, since it's not used in the rendering.\n                _this.setState({\n                    inView: inView,\n                    entry: entry\n                });\n            }\n            if (_this.props.onChange) {\n                // If the user is actively listening for onChange, always trigger it\n                _this.props.onChange(inView, entry);\n            }\n        };\n        _this.state = {\n            inView: !!props.initialInView,\n            entry: undefined\n        };\n        return _this;\n    }\n    var _proto = InView.prototype;\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n        // If a IntersectionObserver option changed, reinit the observer\n        if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold || prevProps.skip !== this.props.skip || prevProps.trackVisibility !== this.props.trackVisibility || prevProps.delay !== this.props.delay) {\n            this.unobserve();\n            this.observeNode();\n        }\n    };\n    _proto.componentWillUnmount = function componentWillUnmount() {\n        this.unobserve();\n        this.node = null;\n    };\n    _proto.observeNode = function observeNode() {\n        if (!this.node || this.props.skip) return;\n        var _this$props = this.props, threshold = _this$props.threshold, root = _this$props.root, rootMargin = _this$props.rootMargin, trackVisibility = _this$props.trackVisibility, delay = _this$props.delay, fallbackInView = _this$props.fallbackInView;\n        this._unobserveCb = observe(this.node, this.handleChange, {\n            threshold: threshold,\n            root: root,\n            rootMargin: rootMargin,\n            // @ts-ignore\n            trackVisibility: trackVisibility,\n            // @ts-ignore\n            delay: delay\n        }, fallbackInView);\n    };\n    _proto.unobserve = function unobserve() {\n        if (this._unobserveCb) {\n            this._unobserveCb();\n            this._unobserveCb = null;\n        }\n    };\n    _proto.render = function render() {\n        if (!isPlainChildren(this.props)) {\n            var _this$state = this.state, inView = _this$state.inView, entry = _this$state.entry;\n            return this.props.children({\n                inView: inView,\n                entry: entry,\n                ref: this.handleNode\n            });\n        }\n        var _this$props2 = this.props, children = _this$props2.children, as = _this$props2.as, props = _objectWithoutPropertiesLoose(_this$props2, _excluded);\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(as || \"div\", _extends({\n            ref: this.handleNode\n        }, props), children);\n    };\n    return InView;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nInView.displayName = \"InView\";\nInView.defaultProps = {\n    threshold: 0,\n    triggerOnce: false,\n    initialInView: false\n};\n/**\r\n * React Hooks make it easy to monitor the `inView` state of your components. Call\r\n * the `useInView` hook with the (optional) [options](#options) you need. It will\r\n * return an array containing a `ref`, the `inView` status and the current\r\n * [`entry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry).\r\n * Assign the `ref` to the DOM element you want to monitor, and the hook will\r\n * report the status.\r\n *\r\n * @example\r\n * ```jsx\r\n * import React from 'react';\r\n * import { useInView } from 'react-intersection-observer';\r\n *\r\n * const Component = () => {\r\n *   const { ref, inView, entry } = useInView({\r\n *       threshold: 0,\r\n *   });\r\n *\r\n *   return (\r\n *     <div ref={ref}>\r\n *       <h2>{`Header inside viewport ${inView}.`}</h2>\r\n *     </div>\r\n *   );\r\n * };\r\n * ```\r\n */ function useInView(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp, threshold = _ref.threshold, delay = _ref.delay, trackVisibility = _ref.trackVisibility, rootMargin = _ref.rootMargin, root = _ref.root, triggerOnce = _ref.triggerOnce, skip = _ref.skip, initialInView = _ref.initialInView, fallbackInView = _ref.fallbackInView;\n    var unobserve = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        inView: !!initialInView\n    }), state = _React$useState[0], setState = _React$useState[1];\n    var setRef = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(node) {\n        if (unobserve.current !== undefined) {\n            unobserve.current();\n            unobserve.current = undefined;\n        } // Skip creating the observer\n        if (skip) return;\n        if (node) {\n            unobserve.current = observe(node, function(inView, entry) {\n                setState({\n                    inView: inView,\n                    entry: entry\n                });\n                if (entry.isIntersecting && triggerOnce && unobserve.current) {\n                    // If it should only trigger once, unobserve the element after it's inView\n                    unobserve.current();\n                    unobserve.current = undefined;\n                }\n            }, {\n                root: root,\n                rootMargin: rootMargin,\n                threshold: threshold,\n                // @ts-ignore\n                trackVisibility: trackVisibility,\n                // @ts-ignore\n                delay: delay\n            }, fallbackInView);\n        }\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        Array.isArray(threshold) ? threshold.toString() : threshold,\n        root,\n        rootMargin,\n        triggerOnce,\n        skip,\n        trackVisibility,\n        fallbackInView,\n        delay\n    ]);\n    /* eslint-disable-next-line */ (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        if (!unobserve.current && state.entry && !triggerOnce && !skip) {\n            // If we don't have a ref, then reset the state (unless the hook is set to only `triggerOnce` or `skip`)\n            // This ensures we correctly reflect the current state - If you aren't observing anything, then nothing is inView\n            setState({\n                inView: !!initialInView\n            });\n        }\n    });\n    var result = [\n        setRef,\n        state.inView,\n        state.entry\n    ]; // Support object destructuring, by adding the specific values.\n    result.ref = result[0];\n    result.inView = result[1];\n    result.entry = result[2];\n    return result;\n}\n //# sourceMappingURL=react-intersection-observer.m.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW50ZXJzZWN0aW9uLW9ic2VydmVyL3JlYWN0LWludGVyc2VjdGlvbi1vYnNlcnZlci5tLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBK0I7QUFDRztBQUVsQyxTQUFTRTtJQUNQQSxXQUFXQyxPQUFPQyxNQUFNLElBQUksU0FBVUMsTUFBTTtRQUMxQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQ3pDLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUV6QixJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQ3RCLElBQUlOLE9BQU9RLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFFBQVFDLE1BQU07b0JBQ3JETCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUMzQjtZQUNGO1FBQ0Y7UUFFQSxPQUFPTDtJQUNUO0lBRUEsT0FBT0gsU0FBU1ksS0FBSyxDQUFDLElBQUksRUFBRVA7QUFDOUI7QUFFQSxTQUFTUSxlQUFlQyxRQUFRLEVBQUVDLFVBQVU7SUFDMUNELFNBQVNMLFNBQVMsR0FBR1IsT0FBT2UsTUFBTSxDQUFDRCxXQUFXTixTQUFTO0lBQ3ZESyxTQUFTTCxTQUFTLENBQUNRLFdBQVcsR0FBR0g7SUFFakNJLGdCQUFnQkosVUFBVUM7QUFDNUI7QUFFQSxTQUFTRyxnQkFBZ0JDLENBQUMsRUFBRUMsQ0FBQztJQUMzQkYsa0JBQWtCakIsT0FBT29CLGNBQWMsSUFBSSxTQUFTSCxnQkFBZ0JDLENBQUMsRUFBRUMsQ0FBQztRQUN0RUQsRUFBRUcsU0FBUyxHQUFHRjtRQUNkLE9BQU9EO0lBQ1Q7SUFFQSxPQUFPRCxnQkFBZ0JDLEdBQUdDO0FBQzVCO0FBRUEsU0FBU0csOEJBQThCaEIsTUFBTSxFQUFFaUIsUUFBUTtJQUNyRCxJQUFJakIsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUM1QixJQUFJSixTQUFTLENBQUM7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bEUsTUFBTTtRQUFFa0UsTUFBTTdDLEtBQUs7S0FBQyxFQUFFLCtEQUErRDtJQUVqSHVFLE9BQU9oQixHQUFHLEdBQUdnQixNQUFNLENBQUMsRUFBRTtJQUN0QkEsT0FBTzVGLE1BQU0sR0FBRzRGLE1BQU0sQ0FBQyxFQUFFO0lBQ3pCQSxPQUFPdkUsS0FBSyxHQUFHdUUsTUFBTSxDQUFDLEVBQUU7SUFDeEIsT0FBT0E7QUFDVDtBQUVnRixDQUNoRix5REFBeUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8tZnJvbnQvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW50ZXJzZWN0aW9uLW9ic2VydmVyL3JlYWN0LWludGVyc2VjdGlvbi1vYnNlcnZlci5tLmpzP2FhNDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG5cbiAgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgb2JzZXJ2ZXJNYXAgPSBuZXcgTWFwKCk7XG52YXIgUm9vdElkcyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgcm9vdElkID0gMDtcbnZhciB1bnN1cHBvcnRlZFZhbHVlID0gdW5kZWZpbmVkO1xuLyoqXHJcbiAqIFdoYXQgc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlmIHRoZSBJbnRlcnNlY3Rpb25PYnNlcnZlciBpcyB1bnN1cHBvcnRlZD9cclxuICogSWRlYWxseSB0aGUgcG9seWZpbGwgaGFzIGJlZW4gbG9hZGVkLCB5b3UgY2FuIGhhdmUgdGhlIGZvbGxvd2luZyBoYXBwZW46XHJcbiAqIC0gYHVuZGVmaW5lZGA6IFRocm93IGFuIGVycm9yXHJcbiAqIC0gYHRydWVgIG9yIGBmYWxzZWA6IFNldCB0aGUgYGluVmlld2AgdmFsdWUgdG8gdGhpcyByZWdhcmRsZXNzIG9mIGludGVyc2VjdGlvbiBzdGF0ZVxyXG4gKiAqKi9cblxuZnVuY3Rpb24gZGVmYXVsdEZhbGxiYWNrSW5WaWV3KGluVmlldykge1xuICB1bnN1cHBvcnRlZFZhbHVlID0gaW5WaWV3O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciB0aGUgcm9vdCBlbGVtZW50XHJcbiAqIEBwYXJhbSByb290XHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRSb290SWQocm9vdCkge1xuICBpZiAoIXJvb3QpIHJldHVybiAnMCc7XG4gIGlmIChSb290SWRzLmhhcyhyb290KSkgcmV0dXJuIFJvb3RJZHMuZ2V0KHJvb3QpO1xuICByb290SWQgKz0gMTtcbiAgUm9vdElkcy5zZXQocm9vdCwgcm9vdElkLnRvU3RyaW5nKCkpO1xuICByZXR1cm4gUm9vdElkcy5nZXQocm9vdCk7XG59XG4vKipcclxuICogQ29udmVydCB0aGUgb3B0aW9ucyB0byBhIHN0cmluZyBJZCwgYmFzZWQgb24gdGhlIHZhbHVlcy5cclxuICogRW5zdXJlcyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgb2JzZXJ2ZXIgd2hlbiBvYnNlcnZpbmcgZWxlbWVudHMgd2l0aCB0aGUgc2FtZSBvcHRpb25zLlxyXG4gKiBAcGFyYW0gb3B0aW9uc1xyXG4gKi9cblxuXG5mdW5jdGlvbiBvcHRpb25zVG9JZChvcHRpb25zKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvcHRpb25zKS5zb3J0KCkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gb3B0aW9uc1trZXldICE9PSB1bmRlZmluZWQ7XG4gIH0pLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleSArIFwiX1wiICsgKGtleSA9PT0gJ3Jvb3QnID8gZ2V0Um9vdElkKG9wdGlvbnMucm9vdCkgOiBvcHRpb25zW2tleV0pO1xuICB9KS50b1N0cmluZygpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcihvcHRpb25zKSB7XG4gIC8vIENyZWF0ZSBhIHVuaXF1ZSBJRCBmb3IgdGhpcyBvYnNlcnZlciBpbnN0YW5jZSwgYmFzZWQgb24gdGhlIHJvb3QsIHJvb3QgbWFyZ2luIGFuZCB0aHJlc2hvbGQuXG4gIHZhciBpZCA9IG9wdGlvbnNUb0lkKG9wdGlvbnMpO1xuICB2YXIgaW5zdGFuY2UgPSBvYnNlcnZlck1hcC5nZXQoaWQpO1xuXG4gIGlmICghaW5zdGFuY2UpIHtcbiAgICAvLyBDcmVhdGUgYSBtYXAgb2YgZWxlbWVudHMgdGhpcyBvYnNlcnZlciBpcyBnb2luZyB0byBvYnNlcnZlLiBFYWNoIGVsZW1lbnQgaGFzIGEgbGlzdCBvZiBjYWxsYmFja3MgdGhhdCBzaG91bGQgYmUgdHJpZ2dlcmVkLCBvbmNlIGl0IGNvbWVzIGludG8gdmlldy5cbiAgICB2YXIgZWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgdmFyIHRocmVzaG9sZHM7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHZhciBfZWxlbWVudHMkZ2V0O1xuXG4gICAgICAgIC8vIFdoaWxlIGl0IHdvdWxkIGJlIG5pY2UgaWYgeW91IGNvdWxkIGp1c3QgbG9vayBhdCBpc0ludGVyc2VjdGluZyB0byBkZXRlcm1pbmUgaWYgdGhlIGNvbXBvbmVudCBpcyBpbnNpZGUgdGhlIHZpZXdwb3J0LCBicm93c2VycyBjYW4ndCBhZ3JlZSBvbiBob3cgdG8gdXNlIGl0LlxuICAgICAgICAvLyAtRmlyZWZveCBpZ25vcmVzIGB0aHJlc2hvbGRgIHdoZW4gY29uc2lkZXJpbmcgYGlzSW50ZXJzZWN0aW5nYCwgc28gaXQgd2lsbCBuZXZlciBiZSBmYWxzZSBhZ2FpbiBpZiBgdGhyZXNob2xkYCBpcyA+IDBcbiAgICAgICAgdmFyIGluVmlldyA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nICYmIHRocmVzaG9sZHMuc29tZShmdW5jdGlvbiAodGhyZXNob2xkKSB7XG4gICAgICAgICAgcmV0dXJuIGVudHJ5LmludGVyc2VjdGlvblJhdGlvID49IHRocmVzaG9sZDtcbiAgICAgICAgfSk7IC8vIEB0cy1pZ25vcmUgc3VwcG9ydCBJbnRlcnNlY3Rpb25PYnNlcnZlciB2MlxuXG4gICAgICAgIGlmIChvcHRpb25zLnRyYWNrVmlzaWJpbGl0eSAmJiB0eXBlb2YgZW50cnkuaXNWaXNpYmxlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIFRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBJbnRlcnNlY3Rpb24gT2JzZXJ2ZXIgdjIsIGZhbGxpbmcgYmFjayB0byB2MSBiZWhhdmlvci5cbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgZW50cnkuaXNWaXNpYmxlID0gaW5WaWV3O1xuICAgICAgICB9XG5cbiAgICAgICAgKF9lbGVtZW50cyRnZXQgPSBlbGVtZW50cy5nZXQoZW50cnkudGFyZ2V0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50cyRnZXQuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhpblZpZXcsIGVudHJ5KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LCBvcHRpb25zKTsgLy8gRW5zdXJlIHdlIGhhdmUgYSB2YWxpZCB0aHJlc2hvbGRzIGFycmF5LiBJZiBub3QsIHVzZSB0aGUgdGhyZXNob2xkIGZyb20gdGhlIG9wdGlvbnNcblxuICAgIHRocmVzaG9sZHMgPSBvYnNlcnZlci50aHJlc2hvbGRzIHx8IChBcnJheS5pc0FycmF5KG9wdGlvbnMudGhyZXNob2xkKSA/IG9wdGlvbnMudGhyZXNob2xkIDogW29wdGlvbnMudGhyZXNob2xkIHx8IDBdKTtcbiAgICBpbnN0YW5jZSA9IHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIG9ic2VydmVyOiBvYnNlcnZlcixcbiAgICAgIGVsZW1lbnRzOiBlbGVtZW50c1xuICAgIH07XG4gICAgb2JzZXJ2ZXJNYXAuc2V0KGlkLCBpbnN0YW5jZSk7XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG4vKipcclxuICogQHBhcmFtIGVsZW1lbnQgLSBET00gRWxlbWVudCB0byBvYnNlcnZlXHJcbiAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHRyaWdnZXIgd2hlbiBpbnRlcnNlY3Rpb24gc3RhdHVzIGNoYW5nZXNcclxuICogQHBhcmFtIG9wdGlvbnMgLSBJbnRlcnNlY3Rpb24gT2JzZXJ2ZXIgb3B0aW9uc1xyXG4gKiBAcGFyYW0gZmFsbGJhY2tJblZpZXcgLSBGYWxsYmFjayBpblZpZXcgdmFsdWUuXHJcbiAqIEByZXR1cm4gRnVuY3Rpb24gLSBDbGVhbnVwIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIHRyaWdnZXJlZCB0byB1bnJlZ2lzdGVyIHRoZSBvYnNlcnZlclxyXG4gKi9cblxuXG5mdW5jdGlvbiBvYnNlcnZlKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zLCBmYWxsYmFja0luVmlldykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKGZhbGxiYWNrSW5WaWV3ID09PSB2b2lkIDApIHtcbiAgICBmYWxsYmFja0luVmlldyA9IHVuc3VwcG9ydGVkVmFsdWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gJ3VuZGVmaW5lZCcgJiYgZmFsbGJhY2tJblZpZXcgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBib3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNhbGxiYWNrKGZhbGxiYWNrSW5WaWV3LCB7XG4gICAgICBpc0ludGVyc2VjdGluZzogZmFsbGJhY2tJblZpZXcsXG4gICAgICB0YXJnZXQ6IGVsZW1lbnQsXG4gICAgICBpbnRlcnNlY3Rpb25SYXRpbzogdHlwZW9mIG9wdGlvbnMudGhyZXNob2xkID09PSAnbnVtYmVyJyA/IG9wdGlvbnMudGhyZXNob2xkIDogMCxcbiAgICAgIHRpbWU6IDAsXG4gICAgICBib3VuZGluZ0NsaWVudFJlY3Q6IGJvdW5kcyxcbiAgICAgIGludGVyc2VjdGlvblJlY3Q6IGJvdW5kcyxcbiAgICAgIHJvb3RCb3VuZHM6IGJvdW5kc1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7Ly8gTm90aGluZyB0byBjbGVhbnVwXG4gICAgfTtcbiAgfSAvLyBBbiBvYnNlcnZlciB3aXRoIHRoZSBzYW1lIG9wdGlvbnMgY2FuIGJlIHJldXNlZCwgc28gbGV0cyB1c2UgdGhpcyBmYWN0XG5cblxuICB2YXIgX2NyZWF0ZU9ic2VydmVyID0gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucyksXG4gICAgICBpZCA9IF9jcmVhdGVPYnNlcnZlci5pZCxcbiAgICAgIG9ic2VydmVyID0gX2NyZWF0ZU9ic2VydmVyLm9ic2VydmVyLFxuICAgICAgZWxlbWVudHMgPSBfY3JlYXRlT2JzZXJ2ZXIuZWxlbWVudHM7IC8vIFJlZ2lzdGVyIHRoZSBjYWxsYmFjayBsaXN0ZW5lciBmb3IgdGhpcyBlbGVtZW50XG5cblxuICB2YXIgY2FsbGJhY2tzID0gZWxlbWVudHMuZ2V0KGVsZW1lbnQpIHx8IFtdO1xuXG4gIGlmICghZWxlbWVudHMuaGFzKGVsZW1lbnQpKSB7XG4gICAgZWxlbWVudHMuc2V0KGVsZW1lbnQsIGNhbGxiYWNrcyk7XG4gIH1cblxuICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gIHJldHVybiBmdW5jdGlvbiB1bm9ic2VydmUoKSB7XG4gICAgLy8gUmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIHRoZSBjYWxsYmFjayBsaXN0XG4gICAgY2FsbGJhY2tzLnNwbGljZShjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayksIDEpO1xuXG4gICAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vIG1vcmUgY2FsbGJhY2sgZXhpc3RzIGZvciBlbGVtZW50LCBzbyBkZXN0cm95IGl0XG4gICAgICBlbGVtZW50c1tcImRlbGV0ZVwiXShlbGVtZW50KTtcbiAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgLy8gTm8gbW9yZSBlbGVtZW50cyBhcmUgYmVpbmcgb2JzZXJ2ZXIgYnkgdGhpcyBpbnN0YW5jZSwgc28gZGVzdHJveSBpdFxuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgb2JzZXJ2ZXJNYXBbXCJkZWxldGVcIl0oaWQpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIF9leGNsdWRlZCA9IFtcImNoaWxkcmVuXCIsIFwiYXNcIiwgXCJ0cmlnZ2VyT25jZVwiLCBcInRocmVzaG9sZFwiLCBcInJvb3RcIiwgXCJyb290TWFyZ2luXCIsIFwib25DaGFuZ2VcIiwgXCJza2lwXCIsIFwidHJhY2tWaXNpYmlsaXR5XCIsIFwiZGVsYXlcIiwgXCJpbml0aWFsSW5WaWV3XCIsIFwiZmFsbGJhY2tJblZpZXdcIl07XG5cbmZ1bmN0aW9uIGlzUGxhaW5DaGlsZHJlbihwcm9wcykge1xuICByZXR1cm4gdHlwZW9mIHByb3BzLmNoaWxkcmVuICE9PSAnZnVuY3Rpb24nO1xufVxuLyoqXHJcbiAjIyBSZW5kZXIgcHJvcHNcclxuXG4gVG8gdXNlIHRoZSBgPEluVmlldz5gIGNvbXBvbmVudCwgeW91IHBhc3MgaXQgYSBmdW5jdGlvbi4gSXQgd2lsbCBiZSBjYWxsZWRcclxuIHdoZW5ldmVyIHRoZSBzdGF0ZSBjaGFuZ2VzLCB3aXRoIHRoZSBuZXcgdmFsdWUgb2YgYGluVmlld2AuIEluIGFkZGl0aW9uIHRvIHRoZVxyXG4gYGluVmlld2AgcHJvcCwgY2hpbGRyZW4gYWxzbyByZWNlaXZlIGEgYHJlZmAgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZVxyXG4gY29udGFpbmluZyBET00gZWxlbWVudC4gVGhpcyBpcyB0aGUgZWxlbWVudCB0aGF0IHRoZSBJbnRlcnNlY3Rpb25PYnNlcnZlciB3aWxsXHJcbiBtb25pdG9yLlxyXG5cbiBJZiB5b3UgbmVlZCBpdCwgeW91IGNhbiBhbHNvIGFjY2VzcyB0aGVcclxuIFtgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5KVxyXG4gb24gYGVudHJ5YCwgZ2l2aW5nIHlvdSBhY2Nlc3MgdG8gYWxsIHRoZSBkZXRhaWxzIGFib3V0IHRoZSBjdXJyZW50IGludGVyc2VjdGlvblxyXG4gc3RhdGUuXHJcblxuIGBgYGpzeFxyXG4gaW1wb3J0IHsgSW5WaWV3IH0gZnJvbSAncmVhY3QtaW50ZXJzZWN0aW9uLW9ic2VydmVyJztcclxuXG4gY29uc3QgQ29tcG9uZW50ID0gKCkgPT4gKFxyXG4gPEluVmlldz5cclxuIHsoeyBpblZpZXcsIHJlZiwgZW50cnkgfSkgPT4gKFxyXG4gICAgICA8ZGl2IHJlZj17cmVmfT5cclxuICAgICAgICA8aDI+e2BIZWFkZXIgaW5zaWRlIHZpZXdwb3J0ICR7aW5WaWV3fS5gfTwvaDI+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgKX1cclxuIDwvSW5WaWV3PlxyXG4gKTtcclxuXG4gZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50O1xyXG4gYGBgXHJcblxuICMjIFBsYWluIGNoaWxkcmVuXHJcblxuIFlvdSBjYW4gcGFzcyBhbnkgZWxlbWVudCB0byB0aGUgYDxJblZpZXcgLz5gLCBhbmQgaXQgd2lsbCBoYW5kbGUgY3JlYXRpbmcgdGhlXHJcbiB3cmFwcGluZyBET00gZWxlbWVudC4gQWRkIGEgaGFuZGxlciB0byB0aGUgYG9uQ2hhbmdlYCBtZXRob2QsIGFuZCBjb250cm9sIHRoZVxyXG4gc3RhdGUgaW4geW91ciBvd24gY29tcG9uZW50LiBBbnkgZXh0cmEgcHJvcHMgeW91IGFkZCB0byBgPEluVmlldz5gIHdpbGwgYmVcclxuIHBhc3NlZCB0byB0aGUgSFRNTCBlbGVtZW50LCBhbGxvd2luZyB5b3Ugc2V0IHRoZSBgY2xhc3NOYW1lYCwgYHN0eWxlYCwgZXRjLlxyXG5cbiBgYGBqc3hcclxuIGltcG9ydCB7IEluVmlldyB9IGZyb20gJ3JlYWN0LWludGVyc2VjdGlvbi1vYnNlcnZlcic7XHJcblxuIGNvbnN0IENvbXBvbmVudCA9ICgpID0+IChcclxuIDxJblZpZXcgYXM9XCJkaXZcIiBvbkNoYW5nZT17KGluVmlldywgZW50cnkpID0+IGNvbnNvbGUubG9nKCdJbnZpZXc6JywgaW5WaWV3KX0+XHJcbiA8aDI+UGxhaW4gY2hpbGRyZW4gYXJlIGFsd2F5cyByZW5kZXJlZC4gVXNlIG9uQ2hhbmdlIHRvIG1vbml0b3Igc3RhdGUuPC9oMj5cclxuIDwvSW5WaWV3PlxyXG4gKTtcclxuXG4gZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50O1xyXG4gYGBgXHJcbiAqL1xuXG5cbnZhciBJblZpZXcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoSW5WaWV3LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBJblZpZXcocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICBfdGhpcy5ub2RlID0gbnVsbDtcbiAgICBfdGhpcy5fdW5vYnNlcnZlQ2IgPSBudWxsO1xuXG4gICAgX3RoaXMuaGFuZGxlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAoX3RoaXMubm9kZSkge1xuICAgICAgICAvLyBDbGVhciB0aGUgb2xkIG9ic2VydmVyLCBiZWZvcmUgd2Ugc3RhcnQgb2JzZXJ2aW5nIGEgbmV3IGVsZW1lbnRcbiAgICAgICAgX3RoaXMudW5vYnNlcnZlKCk7XG5cbiAgICAgICAgaWYgKCFub2RlICYmICFfdGhpcy5wcm9wcy50cmlnZ2VyT25jZSAmJiAhX3RoaXMucHJvcHMuc2tpcCkge1xuICAgICAgICAgIC8vIFJlc2V0IHRoZSBzdGF0ZSBpZiB3ZSBnZXQgYSBuZXcgbm9kZSwgYW5kIHdlIGFyZW4ndCBpZ25vcmluZyB1cGRhdGVzXG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaW5WaWV3OiAhIV90aGlzLnByb3BzLmluaXRpYWxJblZpZXcsXG4gICAgICAgICAgICBlbnRyeTogdW5kZWZpbmVkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX3RoaXMubm9kZSA9IG5vZGUgPyBub2RlIDogbnVsbDtcblxuICAgICAgX3RoaXMub2JzZXJ2ZU5vZGUoKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKGluVmlldywgZW50cnkpIHtcbiAgICAgIGlmIChpblZpZXcgJiYgX3RoaXMucHJvcHMudHJpZ2dlck9uY2UpIHtcbiAgICAgICAgLy8gSWYgYHRyaWdnZXJPbmNlYCBpcyB0cnVlLCB3ZSBzaG91bGQgc3RvcCBvYnNlcnZpbmcgdGhlIGVsZW1lbnQuXG4gICAgICAgIF90aGlzLnVub2JzZXJ2ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzUGxhaW5DaGlsZHJlbihfdGhpcy5wcm9wcykpIHtcbiAgICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgU3RhdGUsIHNvIHdlIGNhbiBwYXNzIGl0IHRvIHRoZSBjaGlsZHJlbiBpbiB0aGUgbmV4dCByZW5kZXIgdXBkYXRlXG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gcmVhc29uIHRvIHVwZGF0ZSB0aGUgc3RhdGUgZm9yIHBsYWluIGNoaWxkcmVuLCBzaW5jZSBpdCdzIG5vdCB1c2VkIGluIHRoZSByZW5kZXJpbmcuXG4gICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBpblZpZXc6IGluVmlldyxcbiAgICAgICAgICBlbnRyeTogZW50cnlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkNoYW5nZSkge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBpcyBhY3RpdmVseSBsaXN0ZW5pbmcgZm9yIG9uQ2hhbmdlLCBhbHdheXMgdHJpZ2dlciBpdFxuICAgICAgICBfdGhpcy5wcm9wcy5vbkNoYW5nZShpblZpZXcsIGVudHJ5KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBpblZpZXc6ICEhcHJvcHMuaW5pdGlhbEluVmlldyxcbiAgICAgIGVudHJ5OiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBJblZpZXcucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgLy8gSWYgYSBJbnRlcnNlY3Rpb25PYnNlcnZlciBvcHRpb24gY2hhbmdlZCwgcmVpbml0IHRoZSBvYnNlcnZlclxuICAgIGlmIChwcmV2UHJvcHMucm9vdE1hcmdpbiAhPT0gdGhpcy5wcm9wcy5yb290TWFyZ2luIHx8IHByZXZQcm9wcy5yb290ICE9PSB0aGlzLnByb3BzLnJvb3QgfHwgcHJldlByb3BzLnRocmVzaG9sZCAhPT0gdGhpcy5wcm9wcy50aHJlc2hvbGQgfHwgcHJldlByb3BzLnNraXAgIT09IHRoaXMucHJvcHMuc2tpcCB8fCBwcmV2UHJvcHMudHJhY2tWaXNpYmlsaXR5ICE9PSB0aGlzLnByb3BzLnRyYWNrVmlzaWJpbGl0eSB8fCBwcmV2UHJvcHMuZGVsYXkgIT09IHRoaXMucHJvcHMuZGVsYXkpIHtcbiAgICAgIHRoaXMudW5vYnNlcnZlKCk7XG4gICAgICB0aGlzLm9ic2VydmVOb2RlKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMudW5vYnNlcnZlKCk7XG4gICAgdGhpcy5ub2RlID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ub2JzZXJ2ZU5vZGUgPSBmdW5jdGlvbiBvYnNlcnZlTm9kZSgpIHtcbiAgICBpZiAoIXRoaXMubm9kZSB8fCB0aGlzLnByb3BzLnNraXApIHJldHVybjtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICB0aHJlc2hvbGQgPSBfdGhpcyRwcm9wcy50aHJlc2hvbGQsXG4gICAgICAgIHJvb3QgPSBfdGhpcyRwcm9wcy5yb290LFxuICAgICAgICByb290TWFyZ2luID0gX3RoaXMkcHJvcHMucm9vdE1hcmdpbixcbiAgICAgICAgdHJhY2tWaXNpYmlsaXR5ID0gX3RoaXMkcHJvcHMudHJhY2tWaXNpYmlsaXR5LFxuICAgICAgICBkZWxheSA9IF90aGlzJHByb3BzLmRlbGF5LFxuICAgICAgICBmYWxsYmFja0luVmlldyA9IF90aGlzJHByb3BzLmZhbGxiYWNrSW5WaWV3O1xuICAgIHRoaXMuX3Vub2JzZXJ2ZUNiID0gb2JzZXJ2ZSh0aGlzLm5vZGUsIHRoaXMuaGFuZGxlQ2hhbmdlLCB7XG4gICAgICB0aHJlc2hvbGQ6IHRocmVzaG9sZCxcbiAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICByb290TWFyZ2luOiByb290TWFyZ2luLFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdHJhY2tWaXNpYmlsaXR5OiB0cmFja1Zpc2liaWxpdHksXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBkZWxheTogZGVsYXlcbiAgICB9LCBmYWxsYmFja0luVmlldyk7XG4gIH07XG5cbiAgX3Byb3RvLnVub2JzZXJ2ZSA9IGZ1bmN0aW9uIHVub2JzZXJ2ZSgpIHtcbiAgICBpZiAodGhpcy5fdW5vYnNlcnZlQ2IpIHtcbiAgICAgIHRoaXMuX3Vub2JzZXJ2ZUNiKCk7XG5cbiAgICAgIHRoaXMuX3Vub2JzZXJ2ZUNiID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICBpZiAoIWlzUGxhaW5DaGlsZHJlbih0aGlzLnByb3BzKSkge1xuICAgICAgdmFyIF90aGlzJHN0YXRlID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICBpblZpZXcgPSBfdGhpcyRzdGF0ZS5pblZpZXcsXG4gICAgICAgICAgZW50cnkgPSBfdGhpcyRzdGF0ZS5lbnRyeTtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuKHtcbiAgICAgICAgaW5WaWV3OiBpblZpZXcsXG4gICAgICAgIGVudHJ5OiBlbnRyeSxcbiAgICAgICAgcmVmOiB0aGlzLmhhbmRsZU5vZGVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzMi5jaGlsZHJlbixcbiAgICAgICAgYXMgPSBfdGhpcyRwcm9wczIuYXMsXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMyLCBfZXhjbHVkZWQpO1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGFzIHx8ICdkaXYnLCBfZXh0ZW5kcyh7XG4gICAgICByZWY6IHRoaXMuaGFuZGxlTm9kZVxuICAgIH0sIHByb3BzKSwgY2hpbGRyZW4pO1xuICB9O1xuXG4gIHJldHVybiBJblZpZXc7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5JblZpZXcuZGlzcGxheU5hbWUgPSAnSW5WaWV3JztcbkluVmlldy5kZWZhdWx0UHJvcHMgPSB7XG4gIHRocmVzaG9sZDogMCxcbiAgdHJpZ2dlck9uY2U6IGZhbHNlLFxuICBpbml0aWFsSW5WaWV3OiBmYWxzZVxufTtcblxuLyoqXHJcbiAqIFJlYWN0IEhvb2tzIG1ha2UgaXQgZWFzeSB0byBtb25pdG9yIHRoZSBgaW5WaWV3YCBzdGF0ZSBvZiB5b3VyIGNvbXBvbmVudHMuIENhbGxcclxuICogdGhlIGB1c2VJblZpZXdgIGhvb2sgd2l0aCB0aGUgKG9wdGlvbmFsKSBbb3B0aW9uc10oI29wdGlvbnMpIHlvdSBuZWVkLiBJdCB3aWxsXHJcbiAqIHJldHVybiBhbiBhcnJheSBjb250YWluaW5nIGEgYHJlZmAsIHRoZSBgaW5WaWV3YCBzdGF0dXMgYW5kIHRoZSBjdXJyZW50XHJcbiAqIFtgZW50cnlgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSkuXHJcbiAqIEFzc2lnbiB0aGUgYHJlZmAgdG8gdGhlIERPTSBlbGVtZW50IHlvdSB3YW50IHRvIG1vbml0b3IsIGFuZCB0aGUgaG9vayB3aWxsXHJcbiAqIHJlcG9ydCB0aGUgc3RhdHVzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc3hcclxuICogaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuICogaW1wb3J0IHsgdXNlSW5WaWV3IH0gZnJvbSAncmVhY3QtaW50ZXJzZWN0aW9uLW9ic2VydmVyJztcclxuICpcclxuICogY29uc3QgQ29tcG9uZW50ID0gKCkgPT4ge1xyXG4gKiAgIGNvbnN0IHsgcmVmLCBpblZpZXcsIGVudHJ5IH0gPSB1c2VJblZpZXcoe1xyXG4gKiAgICAgICB0aHJlc2hvbGQ6IDAsXHJcbiAqICAgfSk7XHJcbiAqXHJcbiAqICAgcmV0dXJuIChcclxuICogICAgIDxkaXYgcmVmPXtyZWZ9PlxyXG4gKiAgICAgICA8aDI+e2BIZWFkZXIgaW5zaWRlIHZpZXdwb3J0ICR7aW5WaWV3fS5gfTwvaDI+XHJcbiAqICAgICA8L2Rpdj5cclxuICogICApO1xyXG4gKiB9O1xyXG4gKiBgYGBcclxuICovXG5cbmZ1bmN0aW9uIHVzZUluVmlldyhfdGVtcCkge1xuICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgdGhyZXNob2xkID0gX3JlZi50aHJlc2hvbGQsXG4gICAgICBkZWxheSA9IF9yZWYuZGVsYXksXG4gICAgICB0cmFja1Zpc2liaWxpdHkgPSBfcmVmLnRyYWNrVmlzaWJpbGl0eSxcbiAgICAgIHJvb3RNYXJnaW4gPSBfcmVmLnJvb3RNYXJnaW4sXG4gICAgICByb290ID0gX3JlZi5yb290LFxuICAgICAgdHJpZ2dlck9uY2UgPSBfcmVmLnRyaWdnZXJPbmNlLFxuICAgICAgc2tpcCA9IF9yZWYuc2tpcCxcbiAgICAgIGluaXRpYWxJblZpZXcgPSBfcmVmLmluaXRpYWxJblZpZXcsXG4gICAgICBmYWxsYmFja0luVmlldyA9IF9yZWYuZmFsbGJhY2tJblZpZXc7XG5cbiAgdmFyIHVub2JzZXJ2ZSA9IFJlYWN0LnVzZVJlZigpO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgaW5WaWV3OiAhIWluaXRpYWxJblZpZXdcbiAgfSksXG4gICAgICBzdGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldFN0YXRlID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHZhciBzZXRSZWYgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmICh1bm9ic2VydmUuY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1bm9ic2VydmUuY3VycmVudCgpO1xuICAgICAgdW5vYnNlcnZlLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgfSAvLyBTa2lwIGNyZWF0aW5nIHRoZSBvYnNlcnZlclxuXG5cbiAgICBpZiAoc2tpcCkgcmV0dXJuO1xuXG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIHVub2JzZXJ2ZS5jdXJyZW50ID0gb2JzZXJ2ZShub2RlLCBmdW5jdGlvbiAoaW5WaWV3LCBlbnRyeSkge1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgaW5WaWV3OiBpblZpZXcsXG4gICAgICAgICAgZW50cnk6IGVudHJ5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZyAmJiB0cmlnZ2VyT25jZSAmJiB1bm9ic2VydmUuY3VycmVudCkge1xuICAgICAgICAgIC8vIElmIGl0IHNob3VsZCBvbmx5IHRyaWdnZXIgb25jZSwgdW5vYnNlcnZlIHRoZSBlbGVtZW50IGFmdGVyIGl0J3MgaW5WaWV3XG4gICAgICAgICAgdW5vYnNlcnZlLmN1cnJlbnQoKTtcbiAgICAgICAgICB1bm9ic2VydmUuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICByb290OiByb290LFxuICAgICAgICByb290TWFyZ2luOiByb290TWFyZ2luLFxuICAgICAgICB0aHJlc2hvbGQ6IHRocmVzaG9sZCxcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0cmFja1Zpc2liaWxpdHk6IHRyYWNrVmlzaWJpbGl0eSxcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBkZWxheTogZGVsYXlcbiAgICAgIH0sIGZhbGxiYWNrSW5WaWV3KTtcbiAgICB9XG4gIH0sIC8vIFdlIGJyZWFrIHRoZSBydWxlIGhlcmUsIGJlY2F1c2Ugd2UgYXJlbid0IGluY2x1ZGluZyB0aGUgYWN0dWFsIGB0aHJlc2hvbGRgIHZhcmlhYmxlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgWy8vIElmIHRoZSB0aHJlc2hvbGQgaXMgYW4gYXJyYXksIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcgc28gaXQgd29uJ3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBBcnJheS5pc0FycmF5KHRocmVzaG9sZCkgPyB0aHJlc2hvbGQudG9TdHJpbmcoKSA6IHRocmVzaG9sZCwgcm9vdCwgcm9vdE1hcmdpbiwgdHJpZ2dlck9uY2UsIHNraXAsIHRyYWNrVmlzaWJpbGl0eSwgZmFsbGJhY2tJblZpZXcsIGRlbGF5XSk7XG4gIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAqL1xuXG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF1bm9ic2VydmUuY3VycmVudCAmJiBzdGF0ZS5lbnRyeSAmJiAhdHJpZ2dlck9uY2UgJiYgIXNraXApIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSByZWYsIHRoZW4gcmVzZXQgdGhlIHN0YXRlICh1bmxlc3MgdGhlIGhvb2sgaXMgc2V0IHRvIG9ubHkgYHRyaWdnZXJPbmNlYCBvciBgc2tpcGApXG4gICAgICAvLyBUaGlzIGVuc3VyZXMgd2UgY29ycmVjdGx5IHJlZmxlY3QgdGhlIGN1cnJlbnQgc3RhdGUgLSBJZiB5b3UgYXJlbid0IG9ic2VydmluZyBhbnl0aGluZywgdGhlbiBub3RoaW5nIGlzIGluVmlld1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBpblZpZXc6ICEhaW5pdGlhbEluVmlld1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgdmFyIHJlc3VsdCA9IFtzZXRSZWYsIHN0YXRlLmluVmlldywgc3RhdGUuZW50cnldOyAvLyBTdXBwb3J0IG9iamVjdCBkZXN0cnVjdHVyaW5nLCBieSBhZGRpbmcgdGhlIHNwZWNpZmljIHZhbHVlcy5cblxuICByZXN1bHQucmVmID0gcmVzdWx0WzBdO1xuICByZXN1bHQuaW5WaWV3ID0gcmVzdWx0WzFdO1xuICByZXN1bHQuZW50cnkgPSByZXN1bHRbMl07XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IEluVmlldywgSW5WaWV3IGFzIGRlZmF1bHQsIGRlZmF1bHRGYWxsYmFja0luVmlldywgb2JzZXJ2ZSwgdXNlSW5WaWV3IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXIubS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsIl9leHRlbmRzIiwiT2JqZWN0IiwiYXNzaWduIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiX2luaGVyaXRzTG9vc2UiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsIl9zZXRQcm90b3R5cGVPZiIsIm8iLCJwIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImV4Y2x1ZGVkIiwic291cmNlS2V5cyIsImtleXMiLCJpbmRleE9mIiwib2JzZXJ2ZXJNYXAiLCJNYXAiLCJSb290SWRzIiwiV2Vha01hcCIsInJvb3RJZCIsInVuc3VwcG9ydGVkVmFsdWUiLCJ1bmRlZmluZWQiLCJkZWZhdWx0RmFsbGJhY2tJblZpZXciLCJpblZpZXciLCJnZXRSb290SWQiLCJyb290IiwiaGFzIiwiZ2V0Iiwic2V0IiwidG9TdHJpbmciLCJvcHRpb25zVG9JZCIsIm9wdGlvbnMiLCJzb3J0IiwiZmlsdGVyIiwibWFwIiwiY3JlYXRlT2JzZXJ2ZXIiLCJpZCIsImluc3RhbmNlIiwiZWxlbWVudHMiLCJ0aHJlc2hvbGRzIiwib2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsImVudHJpZXMiLCJmb3JFYWNoIiwiZW50cnkiLCJfZWxlbWVudHMkZ2V0IiwiaXNJbnRlcnNlY3RpbmciLCJzb21lIiwidGhyZXNob2xkIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJ0cmFja1Zpc2liaWxpdHkiLCJpc1Zpc2libGUiLCJjYWxsYmFjayIsIkFycmF5IiwiaXNBcnJheSIsIm9ic2VydmUiLCJlbGVtZW50IiwiZmFsbGJhY2tJblZpZXciLCJ3aW5kb3ciLCJib3VuZHMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0aW1lIiwiYm91bmRpbmdDbGllbnRSZWN0IiwiaW50ZXJzZWN0aW9uUmVjdCIsInJvb3RCb3VuZHMiLCJfY3JlYXRlT2JzZXJ2ZXIiLCJjYWxsYmFja3MiLCJwdXNoIiwidW5vYnNlcnZlIiwic3BsaWNlIiwic2l6ZSIsImRpc2Nvbm5lY3QiLCJfZXhjbHVkZWQiLCJpc1BsYWluQ2hpbGRyZW4iLCJwcm9wcyIsImNoaWxkcmVuIiwiSW5WaWV3IiwiX1JlYWN0JENvbXBvbmVudCIsIl90aGlzIiwibm9kZSIsIl91bm9ic2VydmVDYiIsImhhbmRsZU5vZGUiLCJ0cmlnZ2VyT25jZSIsInNraXAiLCJzZXRTdGF0ZSIsImluaXRpYWxJblZpZXciLCJvYnNlcnZlTm9kZSIsImhhbmRsZUNoYW5nZSIsIm9uQ2hhbmdlIiwic3RhdGUiLCJfcHJvdG8iLCJjb21wb25lbnREaWRVcGRhdGUiLCJwcmV2UHJvcHMiLCJyb290TWFyZ2luIiwiZGVsYXkiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIl90aGlzJHByb3BzIiwicmVuZGVyIiwiX3RoaXMkc3RhdGUiLCJyZWYiLCJfdGhpcyRwcm9wczIiLCJhcyIsImNyZWF0ZUVsZW1lbnQiLCJDb21wb25lbnQiLCJkaXNwbGF5TmFtZSIsImRlZmF1bHRQcm9wcyIsInVzZUluVmlldyIsIl90ZW1wIiwiX3JlZiIsInVzZVJlZiIsIl9SZWFjdCR1c2VTdGF0ZSIsInVzZVN0YXRlIiwic2V0UmVmIiwidXNlQ2FsbGJhY2siLCJjdXJyZW50IiwicmVzdWx0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-intersection-observer/react-intersection-observer.m.js\n");

/***/ })

};
;